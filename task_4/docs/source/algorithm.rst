=======================
Алгоритм решения задачи
=======================

Основная идея алгоритма
=======================

Чтобы решить задачу, необходимо обойти все пространство ``STATES``

Отбрасывание подпространств по ``COST``
---------------------------------------

Если для вектора ``STATE`` выполняется условие::

    COST(STATE[0]) + COST(STATE[1]) + ... + COST(STATE[K - 1]) > MAX_COST

то при решении задачи можно сэкономить несколько операций,
и не рассматривать ни один вектор ``X``, такой что
``STATE[i] == X[i]`` для всех ``i = 0, 1, ..., K - 1``.

Отбрасывание подпространств по ``REL``
--------------------------------------

Если для вектора ``STATE`` выполняется условие::

    REL(STATE[0]) * REL(STATE[1]) * ... * REL(STATE[T - 1]) < BEST_REL
    
где ``BEST_REL`` - наибольшая уже известная надежность вектора,
то при решении задачи можно сэкономить несколько операций,
и не рассматривать ни один вектор ``X``, такой что
``STATE[i] == X[i]`` для всех ``i = 0, 1, ..., T - 1``.

Реализация алгоритма
====================

Список ``state`` содержит вектор пространтва ``STATES``.

Обходим пространство в лексикографическом порядке::

    (0, ..., 0, 0, 0),
    (0, ..., 0, 0, 1),
    ..................
    (0, ..., 0, 0, M)
    (0, ..., 0, 1, 0)
    ..................
    (M, ..., M, M, M)

В случае, когда по первой части вектора
можно сразу сказать, что он не является решением,
пропускаем обход этого подпространства размерности ``N - K``







