=================
Прикладная задача
=================

Математическая формулировка
===========================

Дано
----

+ Дискретное ``N``-мерное пространство ``STATES``
  - Каждая компонента вектора в этом пространстве принимает значения из множества ``{0, 1, ..., M - 1}``

+ Натуральное число ``MAX_COST``

+ Отображение ``COST`` из пространства ``STATES x {0, 1, ..., N - 1}`` в множество натуральных чисел

+ Отображение ``REL`` из пространства ``STATES x {0, 1, ..., N - 1}`` в интервал ``[0, 1]``

Задача
------

Найти такой вектор ``BEST_STATE``, что значение функции ``STATE_REL`` будет максимально
при выполнении условия ``STATE_COST(BEST_STATE) <= MAX_COST``, где

+ отображение ``STATE_REL`` определяется так::

    STATE_REL(STATE) = REL(STATE[0]) * REL(STATE[1]) * ... * REL(STATE[N - 1])

+ отображение ``STATE_COST`` определяется так::

    STATE_COST(STATE) = COST(STATE[0]) + COST(STATE[1]) + ... + COST(STATE[N - 1])

Если таковых несколько, то ответом является любой.


Алгоритм
========

Основная идея алгоритма
-----------------------

Чтобы решить задачу, необходимо обойти все пространство ``STATES``

Однако, если для вектора ``STATE`` выполняется условие
``COST(STATE[0]) + COST(STATE[1]) + ... + COST(STATE[K - 1]) > MAX_COST``,
то при решении задачи можно сэкономить несколько операций,
и не рассматривать ни один вектор ``X``, такой что
``STATE[i] == X[i]`` для всех ``i = 0, 1, ..., K - 1``.

Алгоритм
--------

Список ``state`` содержит вектор пространтва ``STATES``.

Обходим пространство в лексикографическом порядке::

    (0, ..., 0, 0, 0),
    (0, ..., 0, 0, 1),
    ..................
    (0, ..., 0, 0, M)
    (0, ..., 0, 1, 0)
    ..................
    (M, ..., M, M, M)

В случае, когда по первой части вектора мы можем сразу сказать, что он не является решением,
мы можем пропустить обход подпространства размерности ``N - K``
